![example workflow](https://github.com/serainville/bitbucket-webhooks/actions/workflows/go.yml/badge.svg)
[![Go Report Card](https://goreportcard.com/badge/github.com/serainville/bitbucket-webhooks)](https://goreportcard.com/report/github.com/serainville/bitbucket-webhooks)
# Go Bitbucket Webhook Module
## Overview
This module is used for handling Bitbucket Server Webhook events. Combined with an `http.Server`, events can be validated and processed.


## Installing
### go get

```shell
go get github.com/serainville/bitbucket-webhooks
```

### Importing Bitbucket-Webhooks
Add the following to your project in order to import this module.

```shell
import (
	webhook "github.com/serainville/bitbucket-webhooks"
)
```
## Parsing Webhook Events
Events are parsed using the the `Parse(r *http.Request)` Webhook method. The function returns to data types:

- interface{}
- error

The interface will contain the event type the request is mapped to based on the `X-Event-Key` header found in a Bitbucket Webhook request. 



```golang
func handleEvent(w http.ResponseWriter, r *http.Request) {
    hook := webhook.New()

    _, err := hook.Parse(r)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest))
        log.Println(err)
    }
}

```

The example above ignores the returned interface type. However, additional processing of an event can be performed to all event types or for specific types only. The following example shows how a `switch` logical can be used to further process `pr:opened` and `pr:merged` Bitbucket Webhook events.

```golang
func handleEvent(w http.ResponseWriter, r *http.Request) {
    hook := webhook.New()

    event, err := hook.Parse(r)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest))
        log.Println(err)
    }

	switch evt := event.(type) {
		case PullRequestOpenedPayload:
			// perform additional steps on pr:opened events
		case PullRequestMergedPayload:
			// perform additional steps on pr:merged events
		default:
			// Do nothing or process all other event types the same
	}
}

```

## Options
Options can be set to change the default behaviour and settings of a webhook. 

**WithSecret**
In order to validate the authenticity and intrigity of an incoming Bitbucket Webhook a secret key must be set. The WithSecret option
is used to set the secret key that will be used for HMAC validation.

```golang
webhook.New(WithSecret("WEBOOK_SECRET"))
```

**WithoutHMAC**
In the event that HMAC validation needs to be disabled, the WithoutHMAC option can be used. When used it sets a webhook's disableHMACValidation to true, which causes `Parse()` to skip validation.

```golang
webhook.New(WithoutHMAC())
```

**PreserveBody**
When the body of an `*http.Request` is read using an `*io.Reader` it is cleared. By using the PreserveBody option the body is preserved after being read, allowing other related or unrelated processes the ability to read the body, too. 

```golang
webhook.New(PreserveBody())
```

Multiple options can be set when creating a new Webhook. The following example sets the webhook secret and preserve the body of the `*http.Request` after it has been parsed.

```golang
webhook.New(WithSecret("WEBHOOK_SECRET"), PreserveBody())
```


## HMAC Signature
This module features HMAC signature validation to ensure webhook requests are authentic and sent from a trusted source. HMAC signature hashes are generated using the request body and a secret key. To verify the integrity of the received event, the a signature is generated by this module using the request body and a key.

In order for HMAC signatures to be validated, a webhook must have a secret set. Secrets are stored in the Webhook's `Secret` field, which is set using Webhook's `Secret()` method.

```golang
webhook.New(WithSecret("WEBHOOK_SECRET"))
```

Alternatively, validation can be disabled by using the WithoutHMAC option when creating a new Webhook.
```golang
webhook.New(WithoutHMAC())
```

The following example shows an implementation which sets the expected Bitbucket Webhook secret for HMAC validation.

```golang
func handleBitbucketEvents(w http.ResponseWriter, r *http.Request) {
    hook := webhook.New(WithSecret("WEBHOOK_SECRET"))

    err := hook.Parse(r)
    ...
}
```

HMAC signature verification will be performed on any request received that contains the `X-Hub-Signature` header. When set, the `Parse()` function will expect `webhook.Secret` to be set to a non-zero length value. 

The `Secret` and the request's body will be used to generate an HMAC signature. If the generated signature matches the signature sent with the `X-Hub-Signature` header, the event will be validated. Otherwise, `Parse()` will return a HMAC validation error.
## Examples
### Handling Events
The `Parse(*http.Request)` does not return a struct. Rather, an `interface{}` is returned instead. By doing so, `Parse()` is capable of returning a variety of event types.

The event type of a returned event can be reflected back using `event.(type)`. This allows further processing of returned events based on its event type.


```golang
func handlePullRequests(resp http.ResponseWriter, req *http.Request) {
	hook := v1.New(WithSecret("WEBHOOK_SECRET"))

	event, err := hook.Parse(req)
	if err != nil {
		resp.Write([]byte(err.Error()))
		resp.WriteHeader(403)
		log.Printf("Error: %v", err)
		return
	}

	var rMessage ResponseMessage

	resp.Header().Add("Content-Type", "application/json")

	switch evt := event.(type) {
	case v1.DiagnosticPingEvent:
		rMessage.Msg = "Ignoring diagnostic:ping event"
	case v1.PullRequestOpenedPayload:
		rMessage.Msg = fmt.Sprintf("Processing event '%s', submitter: %s", evt.EventKey, evt.Actor.DisplayName)
	case v1.PullRequestDeclinedPayload:
		rMessage.Msg = fmt.Sprintf("Processing event '%s', submitter: %s", evt.EventKey, evt.Actor.DisplayName)
	default:
		rMessage.Msg = fmt.Sprintf("Event not processed. '%s' events are not supported", req.Header.Get("X-Event-Key"))
		resp.WriteHeader(501)
	}

	jsonBody, _ := json.Marshal(rMessage)
	resp.Write(jsonBody)
	log.Println(rMessage.Msg)
}
```

### Slack Bitbucket Webhook Events
By incorporating the Slack module, events processed by this module can be used to trigger Slack messages, for example.

The following sends a message to a Slack channel whenever a Bitbucket Webhook event is processed.

```golang
import (
    "fmt"

    webhook "github.com/serainville/bitbucket-webhooks"
    "github.com/slack-go/slack"
)

func handlePullRequests(resp http.ResponseWriter, req *http.Request) {
	hook := webhook.New(WithSecret("WEBHOOK_SECRET"))

	event, err := hook.Parse(req)
	if err != nil {
		log.Printf("Error: %v", err)
		return
	}

    var msg string
    var err error
	slackChannelID := "DEVOPS"

	switch evt := event.(type) {
	case v1.PullRequestOpenedPayload:
        msg = fmt.Sprintf("Pull Request Event '%s' submitted by %s -- Repo: %s/%s, PR: %d", 
            evt.EventKey, evt.Actor.DisplayName, evt.PullRequest.FromRef.Project.Name, evt.PullRequest.FromRef.Repository.Name, evt.PullRequest.ID)
        err = sendSlackMessage(msg, slackChannelID)
	default:
        // Nothing to do
        return
	}

    if err != nil {
        log.Println(err)
    }
}


func sendSlackMessage(message string, channelID string) error {
    api := slack.New("TOKEN")

    channelID, timestamp, err := api.PostMessage(
        channelID,
        slack.MsgOptionText(message, false),
    )

    if err != nil {
        return fmt.Errorf("failed to send Slack message to channel: %w", err, channelID)
    }

    return nil
}

```

## Contributing

You are more than welcome to contribute to this project. Fork and make a Pull Request, or create an Issue if you see any problem.

## License
MIT license